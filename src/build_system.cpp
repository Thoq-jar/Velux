#include "build_system.hpp"
#include "configparse.h"
#include "logger.hpp"
#include "sys.hpp"
#include <filesystem>
#include <cstdio>
#include <memory>
#include <fstream>
#include <sstream>

void BuildSystem::build(const ConfigParse::Config& config) {
    Logger::info("Parsing config...", "Builder");

    std::filesystem::create_directories("velux-out/");
    std::filesystem::create_directories(".velux-cache");

    if(!config.dependencies.empty()) {
        Logger::info("Building dependencies...", "Builder");
        for(const std::string& dependency : config.dependencies) {
            buildDependency(dependency);
        }
    }

    const std::string target = config.output;
    const std::vector<std::string> compilers = config.compilers;
    const std::vector<std::string> sources = config.sources;
    const std::vector<std::string> flags = config.flags;
    const std::string language = config.language;

    std::string compiler;

    Logger::info("Finding Compiler...", "Builder");
    for(const std::string& c : compilers) {
        if(Sys::safe_system(c, true)) {
            compiler = c;
            break;
        }
    }

    if(compiler.empty()) {
        Logger::error("Could not find suitable compiler!", "Builder");
        exit(1);
    }

    Logger::info("Generating build.ninja file...", "Builder");
    generateNinjaFile(config, compiler);

    Logger::info("Building...", "Builder");
    Sys::safe_system("ninja -t compdb rule1 rule2 > .velux-cache/compile_commands.json 2>/dev/null");
    if(Sys::safe_system("ninja --quiet") != 0) {
        Logger::error("Build failed. Running ninja again to show errors:", "Builder");
        Sys::safe_system("ninja");
        exit(1);
    }

    Logger::info("Build successfully!", "Builder");
}

void BuildSystem::generateNinjaFile(const ConfigParse::Config& config, const std::string& compiler) {
    std::ofstream ninja_file("build.ninja");
    if(!ninja_file.is_open()) {
        Logger::error("Failed to create build.ninja file!", "Builder");
        exit(1);
    }

    ninja_file << "# +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ #\n";
    ninja_file << "# +-+ Generated by Velux build system +-+ #\n";
    ninja_file << "# +-+-+-+-+-+-+ DO NOT EDIT +-+-+-+-+-+-+ #\n";
    ninja_file << "# +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ #\n";
    ninja_file << "\n";

    ninja_file << "ninja_required_version = 1.5\n";
    ninja_file << "builddir = .velux-cache\n\n";

    ninja_file << "cc = " << compiler << "\n";

    std::string cflags = config.language == "CXX" ? "-std=c++" + config.version : "-std=c" + config.version;
    for(const auto& flag : config.flags) {
        cflags += " " + flag;
    }
    for(const auto& inc : config.include) {
        cflags += " -I" + inc;
    }

    if(std::string pkg_flags = getPkgConfigFlags(config); !pkg_flags.empty()) {
        cflags += " " + pkg_flags;
    }

    ninja_file << "cflags = " << cflags << "\n";

    std::string ldflags;
    addDependencyLibrariesString(config, ldflags);
    if(!ldflags.empty()) {
        ninja_file << "ldflags = " << ldflags << "\n";
    }

    ninja_file << "\n";

    if(config.type == "library") {
        ninja_file << "rule cc\n";
        ninja_file << "  command = $cc $cflags -c $in -o $out\n";
        ninja_file << "  depfile = $out.d\n";
        ninja_file << "  deps = gcc\n\n";

        ninja_file << "rule ar\n";
        ninja_file << "  command = ar rcs $out $in\n\n";

        std::vector<std::string> object_files;
        for(const auto& src : config.sources) {
            std::string obj_file = ".velux-cache/" + src.substr(0, src.find_last_of('.')) + ".o";
            std::string obj_name = src.substr(src.find_last_of('/') + 1);
            obj_name = obj_name.substr(0, obj_name.find_last_of('.')) + ".o";
            obj_file = ".velux-cache/" + obj_name;
            object_files.push_back(obj_file);
            ninja_file << "build " << obj_file << ": cc " << src << "\n";
        }
        ninja_file << "\n";

        std::string output_path = "velux-out/" + config.output;
        ninja_file << "build " << output_path << ": ar";
        for(const auto& obj : object_files) {
            ninja_file << " " << obj;
        }
        ninja_file << "\n\n";

        ninja_file << "default " << output_path << "\n";
    } else {
        ninja_file << "rule cc\n";
        ninja_file << "  command = $cc $cflags -c $in -o $out\n";
        ninja_file << "  depfile = $out.d\n";
        ninja_file << "  deps = gcc\n\n";

        ninja_file << "rule link\n";
        ninja_file << "  command = $cc -o $out $in";
        if(!ldflags.empty()) {
            ninja_file << " $ldflags";
        }
        ninja_file << "\n\n";

        std::vector<std::string> object_files;
        for(const auto& src : config.sources) {
            std::string obj_name = src.substr(src.find_last_of('/') + 1);
            obj_name = obj_name.substr(0, obj_name.find_last_of('.')) + ".o";
            std::string obj_file = ".velux-cache/" + obj_name;
            object_files.push_back(obj_file);
            ninja_file << "build " << obj_file << ": cc " << src << "\n";
        }
        ninja_file << "\n";

        std::string output_path = "velux-out/" + config.output;
        ninja_file << "build " << output_path << ": link";
        for(const auto& obj : object_files) {
            ninja_file << " " << obj;
        }
        ninja_file << "\n\n";

        ninja_file << "default " << output_path << "\n";
    }

    ninja_file.close();
    Logger::info("Successfully generated build.ninja", "Builder");
}

std::string BuildSystem::getPkgConfigFlags(const ConfigParse::Config& config) {
    if(config.find_pkg.empty()) {
        return "";
    }

    Logger::info("Using pkg-config for packages...", "Builder-Configurator");

    if(!Sys::safe_system("pkg-config", true)) {
        Logger::error("pkg-config is not available on this system!", "Builder-Configurator");
        exit(1);
    }

    for(const std::string& package : config.find_pkg) {
        if(std::string check_cmd = "pkg-config --exists " + package; !Sys::safe_system(check_cmd, true)) {
            Logger::error("Package '" + package + "' not found by pkg-config!", "Builder-Configurator");
            exit(1);
        }
    }

    std::string pkg_config_cmd = "pkg-config --cflags --libs ";
    for(const std::string& package : config.find_pkg) {
        pkg_config_cmd += package + " ";
    }

    try {
        if(std::string pkg_flags = executeCommand(pkg_config_cmd); !pkg_flags.empty()) {
            Logger::info("Added pkg-config flags: " + pkg_flags, "Builder-Configurator");
            return pkg_flags;
        }
    } catch(const std::exception& e) {
        Logger::error("Failed to execute pkg-config: " + std::string(e.what()), "Builder-Configurator");
        exit(1);
    }

    return "";
}

void BuildSystem::addDependencyLibrariesString(const ConfigParse::Config& config, std::string& ldflags) {
    if(config.dependencies.empty()) {
        return;
    }

    for(const std::string& dependency : config.dependencies) {
        if(std::string dep_lib = getDependencyLibraryPath(dependency); !dep_lib.empty()) {
            ldflags += dep_lib + " ";
        }
    }
}

std::string BuildSystem::executeCommand(const std::string& command) {
    const std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
    if(!pipe) {
        throw std::runtime_error("popen() failed!");
    }

    std::string result;
    char buffer[128];
    while(fgets(buffer, sizeof buffer, pipe.get()) != nullptr) {
        result += buffer;
    }

    if(!result.empty() && result.back() == '\n') {
        result.pop_back();
    }

    return result;
}

void BuildSystem::addPkgConfigFlags(const ConfigParse::Config& config, std::string& build_cmd) {
    if(const std::string flags = getPkgConfigFlags(config); !flags.empty()) {
        build_cmd += flags + " ";
    }
}

void BuildSystem::addDependencyLibraries(const ConfigParse::Config& config, std::string& build_cmd) {
    addDependencyLibrariesString(config, build_cmd);
}

void BuildSystem::buildDependency(const std::string& dependencyPath) {
    Logger::info("Building dependency: " + dependencyPath, "Builder-Dependency");

    if(!std::filesystem::exists(dependencyPath)) {
        Logger::error("Dependency path does not exist: " + dependencyPath, "Builder-Dependency");
        return;
    }

    const std::string configPath = dependencyPath + "/velux.json";
    if(!std::filesystem::exists(configPath)) {
        Logger::error("No velux.json found in dependency: " + dependencyPath, "Builder-Dependency");
        return;
    }

    try {
        const ConfigParse::Config depConfig = ConfigParse::parseConfigFromFile(configPath);
        const std::string originalDir = std::filesystem::current_path();

        std::filesystem::current_path(dependencyPath);

        build(depConfig);

        std::filesystem::current_path(originalDir);

        Logger::info("Successfully built dependency: " + dependencyPath, "Builder-Dependency");
    } catch(const std::exception& e) {
        Logger::error("Failed to build dependency " + dependencyPath + ": " + e.what(), "Builder-Dependency");
        exit(1);
    }
}

std::string BuildSystem::getDependencyLibraryPath(const std::string& dependencyPath) {
    const std::string configPath = dependencyPath + "/velux.json";

    try {
        const ConfigParse::Config depConfig = ConfigParse::parseConfigFromFile(configPath);

        if(std::string libPath = dependencyPath + "/velux-out/" + depConfig.output; std::filesystem::exists(libPath)) {
            return libPath;
        }
    } catch(const std::exception& ex) {
        Logger::error(ex.what(), "Builder-Resolver");
        Logger::error("Could not determine library path for dependency: " + dependencyPath, "Builder-Resolver");
    }

    return "";
}
